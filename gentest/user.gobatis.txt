// Please don't edit this file!
package gentest

import (
	"context"
	"database/sql"
	"errors"
	"reflect"
	"time"

	gobatis "github.com/runner-mei/GoBatis"
)

func init() {
	gobatis.Init(func(ctx *gobatis.InitContext) error {
		{ //// UserDao.Insert
			if _, exists := ctx.Statements["UserDao.Insert"]; !exists {
				sqlStr := "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (#{username},#{phone},#{address},#{status},#{birth_day},CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)"
				switch ctx.Dialect {
				case gobatis.ToDbType("mssql"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n output inserted.id\r\n values (#{username},#{phone},#{address},#{status},#{birth_day},CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)"
				case gobatis.ToDbType("postgres"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (#{username},#{phone},#{address},#{status},#{birth_day},CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) returning id"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.Insert",
					gobatis.StatementTypeInsert,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.Insert"] = stmt
			}
		}
		{ //// UserDao.Upsert
			if _, exists := ctx.Statements["UserDao.Upsert"]; !exists {
				sqlStr := ""
				switch ctx.Dialect {
				case gobatis.ToDbType("mssql"):
					sqlStr = "MERGE auth_users USING (\r\n     VALUES (?,?,?,?,?, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\r\n ) AS foo (username, phone, address, status, birth_day, created_at, updated_at)\r\n ON auth_users.username = foo.username\r\n WHEN MATCHED THEN\r\n    UPDATE SET username=foo.username, phone=foo.phone, address=foo.address, status=foo.status, birth_day=foo.birth_day, updated_at=foo.updated_at\r\n WHEN NOT MATCHED THEN\r\n    INSERT (username, phone, address, status, birth_day, created_at, updated_at)\r\n    VALUES (foo.username, foo.phone, foo.address, foo.status, foo.birth_day,  foo.created_at, foo.updated_at);"
				case gobatis.ToDbType("mysql"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (?,?,?,?,?,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\r\n on duplicate key update\r\n   username=values(username), phone=values(phone), address=values(address),\r\n   status=values(status), birth_day=values(birth_day), updated_at=CURRENT_TIMESTAMP"
				case gobatis.ToDbType("postgres"):
					sqlStr = "insert into auth_users(username, phone, address, status, birth_day, created_at, updated_at)\r\n values (?,?,?,?,?,CURRENT_TIMESTAMP, CURRENT_TIMESTAMP)\r\n on duplicate key update\r\n   username=values(username), phone=values(phone), address=values(address),\r\n   status=values(status), birth_day=values(birth_day), updated_at=CURRENT_TIMESTAMP"
				}
				if sqlStr == "" {
					s, err := gobatis.GenerateUpsertSQL(ctx.Dialect, ctx.Mapper,
						reflect.TypeOf(&User{}),
						nil,
						nil, false)
					if err != nil {
						return gobatis.ErrForGenerateStmt(err, "generate UserDao.Upsert error")
					}
					sqlStr = s
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.Upsert",
					gobatis.StatementTypeInsert,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.Upsert"] = stmt
			}
		}
		{ //// UserDao.Update
			if _, exists := ctx.Statements["UserDao.Update"]; !exists {
				sqlStr := "UPDATE auth_users\r\n SET username=#{u.username},\r\n     phone=#{u.phone},\r\n     address=#{u.address},\r\n     status=#{u.status},\r\n     birth_day=#{u.birth_day},\r\n     updated_at=CURRENT_TIMESTAMP\r\n WHERE id=#{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.Update",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.Update"] = stmt
			}
		}
		{ //// UserDao.UpdateName
			if _, exists := ctx.Statements["UserDao.UpdateName"]; !exists {
				sqlStr := "UPDATE auth_users\r\n SET username=#{username},\r\n     updated_at=CURRENT_TIMESTAMP\r\n WHERE id=#{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.UpdateName",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.UpdateName"] = stmt
			}
		}
		{ //// UserDao.DeleteAll
			if _, exists := ctx.Statements["UserDao.DeleteAll"]; !exists {
				sqlStr := "DELETE FROM auth_users"
				switch ctx.Dialect {
				case gobatis.ToDbType("postgres"):
					sqlStr = "DELETE FROM auth_users"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.DeleteAll",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.DeleteAll"] = stmt
			}
		}
		{ //// UserDao.Delete
			if _, exists := ctx.Statements["UserDao.Delete"]; !exists {
				sqlStr := "DELETE FROM auth_users WHERE id=?"
				switch ctx.Dialect {
				case gobatis.ToDbType("postgres"):
					sqlStr = "DELETE FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.Delete",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.Delete"] = stmt
			}
		}
		{ //// UserDao.Get
			if _, exists := ctx.Statements["UserDao.Get"]; !exists {
				sqlStr := "select * FROM auth_users WHERE id=?"
				switch ctx.Dialect {
				case gobatis.ToDbType("postgres"):
					sqlStr = "select * FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.Get",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.Get"] = stmt
			}
		}
		{ //// UserDao.GetReturnNoPtr
			if _, exists := ctx.Statements["UserDao.GetReturnNoPtr"]; !exists {
				sqlStr := "select * FROM auth_users WHERE id=?"
				switch ctx.Dialect {
				case gobatis.ToDbType("postgres"):
					sqlStr = "select * FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.GetReturnNoPtr",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.GetReturnNoPtr"] = stmt
			}
		}
		{ //// UserDao.GetName
			if _, exists := ctx.Statements["UserDao.GetName"]; !exists {
				sqlStr := "select username FROM auth_users WHERE id=?"
				switch ctx.Dialect {
				case gobatis.ToDbType("postgres"):
					sqlStr = "select username FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.GetName",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.GetName"] = stmt
			}
		}
		{ //// UserDao.GetNames
			if _, exists := ctx.Statements["UserDao.GetNames"]; !exists {
				sqlStr := "select username FROM auth_users"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.GetNames",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.GetNames"] = stmt
			}
		}
		{ //// UserDao.GetMap
			if _, exists := ctx.Statements["UserDao.GetMap"]; !exists {
				sqlStr := "select * FROM auth_users WHERE id=?"
				switch ctx.Dialect {
				case gobatis.ToDbType("postgres"):
					sqlStr = "select * FROM auth_users WHERE id=$1"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.GetMap",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.GetMap"] = stmt
			}
		}
		{ //// UserDao.Count
			if _, exists := ctx.Statements["UserDao.Count"]; !exists {
				sqlStr := "select count(*) from auth_users"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.Count",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.Count"] = stmt
			}
		}
		{ //// UserDao.List
			if _, exists := ctx.Statements["UserDao.List"]; !exists {
				sqlStr := "select * from auth_users offset #{offset} limit  #{size}"
				switch ctx.Dialect {
				case gobatis.ToDbType("mssql"):
					sqlStr = "select * from auth_users ORDER BY username OFFSET #{offset} ROWS FETCH NEXT #{size}  ROWS ONLY"
				case gobatis.ToDbType("mysql"):
					sqlStr = "select * from auth_users limit #{offset}, #{size}"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.List",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.List"] = stmt
			}
		}
		{ //// UserDao.ListMap
			if _, exists := ctx.Statements["UserDao.ListMap"]; !exists {
				sqlStr := "select * from auth_users offset #{offset} limit  #{size}"
				switch ctx.Dialect {
				case gobatis.ToDbType("mssql"):
					sqlStr = "select * from auth_users ORDER BY username OFFSET #{offset} ROWS FETCH NEXT #{size}  ROWS ONLY"
				case gobatis.ToDbType("mysql"):
					sqlStr = "select * from auth_users limit #{offset}, #{size}"
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.ListMap",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.ListMap"] = stmt
			}
		}
		{ //// UserDao.GetNameByID
			if _, exists := ctx.Statements["UserDao.GetNameByID"]; !exists {
				sqlStr := "select username from auth_users where id = #{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.GetNameByID",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.GetNameByID"] = stmt
			}
		}
		{ //// UserDao.Roles
			if _, exists := ctx.Statements["UserDao.Roles"]; !exists {
				sqlStr := "select * from auth_roles where exists(\r\n            select * from auth_users_and_roles\r\n            where user_id = #{id} and auth_roles.id = auth_users_and_roles.role_id)"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserDao.Roles",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserDao.Roles"] = stmt
			}
		}
		return nil
	})
}

func NewUserDao(ref gobatis.SqlSession, userProfiles UserProfiles) UserDao {
	if ref == nil {
		panic(errors.New("param 'ref' is nil"))
	}
	if reference, ok := ref.(*gobatis.Reference); ok {
		if reference.SqlSession == nil {
			panic(errors.New("param 'ref.SqlSession' is nil"))
		}
	} else if valueReference, ok := ref.(gobatis.Reference); ok {
		if valueReference.SqlSession == nil {
			panic(errors.New("param 'ref.SqlSession' is nil"))
		}
	}
	return &UserDaoImpl{session: ref,
		userProfiles: userProfiles}
}

type UserDaoImpl struct {
	userProfiles UserProfiles
	session      gobatis.SqlSession
}

func (impl *UserDaoImpl) Insert(u *User) (int64, error) {
	return impl.session.Insert(context.Background(), "UserDao.Insert",
		[]string{
			"u",
		},
		[]interface{}{
			u,
		})
}

func (impl *UserDaoImpl) Upsert(u *User) (int64, error) {
	return impl.session.Insert(context.Background(), "UserDao.Upsert",
		[]string{
			"u",
		},
		[]interface{}{
			u,
		})
}

func (impl *UserDaoImpl) Update(id int64, u *User) (int64, error) {
	return impl.session.Update(context.Background(), "UserDao.Update",
		[]string{
			"id",
			"u",
		},
		[]interface{}{
			id,
			u,
		})
}

func (impl *UserDaoImpl) UpdateName(id int64, username string) (int64, error) {
	return impl.session.Update(context.Background(), "UserDao.UpdateName",
		[]string{
			"id",
			"username",
		},
		[]interface{}{
			id,
			username,
		})
}

func (impl *UserDaoImpl) DeleteAll() (int64, error) {
	return impl.session.Delete(context.Background(), "UserDao.DeleteAll", nil, nil)
}

func (impl *UserDaoImpl) Delete(id int64) (int64, error) {
	return impl.session.Delete(context.Background(), "UserDao.Delete",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		})
}

func (impl *UserDaoImpl) Get(id int64) (*User, error) {
	var instance = &User{}

	err := impl.session.SelectOne(context.Background(), "UserDao.Get",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(instance)
	if err != nil {
		return nil, err
	}

	return instance, nil
}

func (impl *UserDaoImpl) GetReturnNoPtr(id int64) (User, error) {
	var instance User

	err := impl.session.SelectOne(context.Background(), "UserDao.GetReturnNoPtr",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&instance)
	if err != nil {
		return instance, err
	}

	return instance, nil
}

func (impl *UserDaoImpl) GetName(id int64) (string, error) {
	var instance string
	var nullable gobatis.Nullable
	nullable.Value = &instance

	err := impl.session.SelectOne(context.Background(), "UserDao.GetName",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&nullable)
	if err != nil {
		return "", err
	}
	if !nullable.Valid {
		return "", sql.ErrNoRows
	}

	return instance, nil
}

func (impl *UserDaoImpl) GetNames() ([]string, error) {
	var instances []string
	results := impl.session.Select(context.Background(), "UserDao.GetNames", nil, nil)
	err := results.ScanSlice(&instances)
	if err != nil {
		return nil, err
	}
	return instances, nil
}

func (impl *UserDaoImpl) GetMap(id int64) (map[string]interface{}, error) {
	var instance map[string]interface{}

	err := impl.session.SelectOne(context.Background(), "UserDao.GetMap",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&instance)
	if err != nil {
		return nil, err
	}

	return instance, nil
}

func (impl *UserDaoImpl) Count() (int64, error) {
	var instance int64
	var nullable gobatis.Nullable
	nullable.Value = &instance

	err := impl.session.SelectOne(context.Background(), "UserDao.Count", nil, nil).Scan(&nullable)
	if err != nil {
		return 0, err
	}
	if !nullable.Valid {
		return 0, sql.ErrNoRows
	}

	return instance, nil
}

func (impl *UserDaoImpl) List(offset int, size int) (users []*User, err error) {
	results := impl.session.Select(context.Background(), "UserDao.List",
		[]string{
			"offset",
			"size",
		},
		[]interface{}{
			offset,
			size,
		})
	err = results.ScanSlice(&users)
	if err != nil {
		return nil, err
	}
	return users, nil
}

func (impl *UserDaoImpl) ListMap(offset int, size int) (users map[int64]*User, err error) {
	results := impl.session.Select(context.Background(), "UserDao.ListMap",
		[]string{
			"offset",
			"size",
		},
		[]interface{}{
			offset,
			size,
		})
	err = results.ScanResults(&users)
	if err != nil {
		return nil, err
	}
	return users, nil
}

func (impl *UserDaoImpl) GetNameByID(id int64) (string, error) {
	var instance string
	var nullable gobatis.Nullable
	nullable.Value = &instance

	err := impl.session.SelectOne(context.Background(), "UserDao.GetNameByID",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(&nullable)
	if err != nil {
		return "", err
	}
	if !nullable.Valid {
		return "", sql.ErrNoRows
	}

	return instance, nil
}

func (impl *UserDaoImpl) Roles(id int64) ([]Role, error) {
	var instances []Role
	results := impl.session.Select(context.Background(), "UserDao.Roles",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		})
	err := results.ScanSlice(&instances)
	if err != nil {
		return nil, err
	}
	return instances, nil
}

func (impl *UserDaoImpl) InsertProfile(profile *UserProfile) (int64, error) {
	return impl.userProfiles.Insert(profile)
}

func (impl *UserDaoImpl) DeleteProfile(userID int64) (int64, error) {
	return impl.userProfiles.DeleteByUserID(userID)
}

func (impl *UserDaoImpl) DeleteProfiles(userIDs ...int64) (int64, error) {
	return impl.userProfiles.DeleteByUserIDs(userIDs...)
}

func (impl *UserDaoImpl) Profiles(userID int64) ([]*UserProfile, error) {
	return impl.userProfiles.List(userID)
}

func init() {
	gobatis.Init(func(ctx *gobatis.InitContext) error {
		{ //// UserProfiles.Insert
			if _, exists := ctx.Statements["UserProfiles.Insert"]; !exists {
				sqlStr, err := gobatis.GenerateInsertSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), false)
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.Insert error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.Insert",
					gobatis.StatementTypeInsert,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Insert"] = stmt
			}
		}
		{ //// UserProfiles.Update
			if _, exists := ctx.Statements["UserProfiles.Update"]; !exists {
				sqlStr, err := gobatis.GenerateUpdateSQL(ctx.Dialect, ctx.Mapper,
					"u.", reflect.TypeOf(&UserProfile{}),
					[]string{
						"id",
					},
					[]reflect.Type{
						reflect.TypeOf(new(int64)).Elem(),
					})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.Update error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.Update",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Update"] = stmt
			}
		}
		{ //// UserProfiles.SetValue
			if _, exists := ctx.Statements["UserProfiles.SetValue"]; !exists {
				sqlStr, err := gobatis.GenerateUpdateSQL2(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), reflect.TypeOf(new(int64)), "id", []string{
						"value",
					})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.SetValue error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.SetValue",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.SetValue"] = stmt
			}
		}
		{ //// UserProfiles.SetUpdatedAt
			if _, exists := ctx.Statements["UserProfiles.SetUpdatedAt"]; !exists {
				sqlStr, err := gobatis.GenerateUpdateSQL2(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}), reflect.TypeOf(new(int64)), "id", []string{
						"updatedAt",
					})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.SetUpdatedAt error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.SetUpdatedAt",
					gobatis.StatementTypeUpdate,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.SetUpdatedAt"] = stmt
			}
		}
		{ //// UserProfiles.DeleteByUserID
			if _, exists := ctx.Statements["UserProfiles.DeleteByUserID"]; !exists {
				sqlStr, err := gobatis.GenerateDeleteSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}),
					[]string{
						"userID",
					},
					[]reflect.Type{
						reflect.TypeOf(new(int64)).Elem(),
					},
					[]gobatis.Filter{})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.DeleteByUserID error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.DeleteByUserID",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.DeleteByUserID"] = stmt
			}
		}
		{ //// UserProfiles.DeleteByUserIDs
			if _, exists := ctx.Statements["UserProfiles.DeleteByUserIDs"]; !exists {
				sqlStr, err := gobatis.GenerateDeleteSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}),
					[]string{
						"userIDs",
					},
					[]reflect.Type{
						reflect.TypeOf([]int64{}),
					},
					[]gobatis.Filter{})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.DeleteByUserIDs error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.DeleteByUserIDs",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.DeleteByUserIDs"] = stmt
			}
		}
		{ //// UserProfiles.DeleteAll
			if _, exists := ctx.Statements["UserProfiles.DeleteAll"]; !exists {
				sqlStr, err := gobatis.GenerateDeleteSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}),
					[]string{},
					[]reflect.Type{},
					[]gobatis.Filter{})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.DeleteAll error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.DeleteAll",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.DeleteAll"] = stmt
			}
		}
		{ //// UserProfiles.Delete
			if _, exists := ctx.Statements["UserProfiles.Delete"]; !exists {
				sqlStr, err := gobatis.GenerateDeleteSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}),
					[]string{
						"id",
					},
					[]reflect.Type{
						reflect.TypeOf(new(int64)).Elem(),
					},
					[]gobatis.Filter{})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.Delete error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.Delete",
					gobatis.StatementTypeDelete,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Delete"] = stmt
			}
		}
		{ //// UserProfiles.Get
			if _, exists := ctx.Statements["UserProfiles.Get"]; !exists {
				sqlStr, err := gobatis.GenerateSelectSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}),
					[]string{
						"id",
					},
					[]reflect.Type{
						reflect.TypeOf(new(int64)).Elem(),
					},
					[]gobatis.Filter{},
					"")
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.Get error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.Get",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Get"] = stmt
			}
		}
		{ //// UserProfiles.List
			if _, exists := ctx.Statements["UserProfiles.List"]; !exists {
				sqlStr, err := gobatis.GenerateSelectSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}),
					[]string{
						"userID",
					},
					[]reflect.Type{
						reflect.TypeOf(new(int64)).Elem(),
					},
					[]gobatis.Filter{},
					"")
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.List error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.List",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.List"] = stmt
			}
		}
		{ //// UserProfiles.Count
			if _, exists := ctx.Statements["UserProfiles.Count"]; !exists {
				sqlStr, err := gobatis.GenerateCountSQL(ctx.Dialect, ctx.Mapper,
					reflect.TypeOf(&UserProfile{}),
					[]string{},
					[]reflect.Type{},
					[]gobatis.Filter{})
				if err != nil {
					return gobatis.ErrForGenerateStmt(err, "generate UserProfiles.Count error")
				}
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.Count",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.Count"] = stmt
			}
		}
		{ //// UserProfiles.FindByID1
			if _, exists := ctx.Statements["UserProfiles.FindByID1"]; !exists {
				sqlStr := "SELECT p.id as \"p.id\",\r\n                 p.user_id as \"p.user_id\",\r\n                 p.name as \"p.name\",\r\n                 p.value \"p.value\",\r\n                 p.created_at as \"p.created_at\",\r\n                 p.updated_at as \"p.updated_at\",\r\n                 u.id as \"u.id\",\r\n                 u.username as \"u.username\"\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.id = #{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.FindByID1",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.FindByID1"] = stmt
			}
		}
		{ //// UserProfiles.FindByID2
			if _, exists := ctx.Statements["UserProfiles.FindByID2"]; !exists {
				sqlStr := "SELECT p.id as p_id,\r\n                 p.user_id as p_user_id,\r\n                 p.name as p_name,\r\n                 p.value p_value,\r\n                 p.created_at as p_created_at,\r\n                 p.updated_at as p_updated_at,\r\n                 u.id as u_id,\r\n                 u.username as u_username\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.id = #{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.FindByID2",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.FindByID2"] = stmt
			}
		}
		{ //// UserProfiles.FindByID3
			if _, exists := ctx.Statements["UserProfiles.FindByID3"]; !exists {
				sqlStr := "SELECT p.id,\r\n                 p.user_id,\r\n                 p.name,\r\n                 p.value,\r\n                 p.created_at,\r\n                 p.updated_at,\r\n                 u.id as userid,\r\n                 u.username as username\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.id = #{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.FindByID3",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.FindByID3"] = stmt
			}
		}
		{ //// UserProfiles.FindByID4
			if _, exists := ctx.Statements["UserProfiles.FindByID4"]; !exists {
				sqlStr := "SELECT p.id as p_id,\r\n                 p.user_id as p_user_id,\r\n                 p.name as p_name,\r\n                 p.value p_value,\r\n                 p.created_at as p_created_at,\r\n                 p.updated_at as p_updated_at,\r\n                 u.id as userid,\r\n                 u.username as username\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.id = #{id}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.FindByID4",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.FindByID4"] = stmt
			}
		}
		{ //// UserProfiles.ListByUserID1
			if _, exists := ctx.Statements["UserProfiles.ListByUserID1"]; !exists {
				sqlStr := "SELECT p.id as p_id,\r\n                 p.user_id as p_user_id,\r\n                 p.name as p_name,\r\n                 p.value p_value,\r\n                 p.created_at as p_created_at,\r\n                 p.updated_at as p_updated_at,\r\n                 u.id as u_id,\r\n                 u.username as u_username\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.user_id = #{userID}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.ListByUserID1",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.ListByUserID1"] = stmt
			}
		}
		{ //// UserProfiles.ListByUserID2
			if _, exists := ctx.Statements["UserProfiles.ListByUserID2"]; !exists {
				sqlStr := "SELECT p.id as \"p.id\",\r\n                 p.user_id as \"p.user_id\",\r\n                 p.name as \"p.name\",\r\n                 p.value \"p.value\",\r\n                 p.created_at as \"p.created_at\",\r\n                 p.updated_at as \"p.updated_at\",\r\n                 u.id as \"u.id\",\r\n                 u.username as \"u.username\"\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.user_id = #{userID}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.ListByUserID2",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.ListByUserID2"] = stmt
			}
		}
		{ //// UserProfiles.ListByUserID3
			if _, exists := ctx.Statements["UserProfiles.ListByUserID3"]; !exists {
				sqlStr := "SELECT p.id,\r\n                 p.user_id,\r\n                 p.name,\r\n                 p.value,\r\n                 p.created_at,\r\n                 p.updated_at,\r\n                 u.id as userids,\r\n                 u.username as usernames\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.user_id = #{userID}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.ListByUserID3",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.ListByUserID3"] = stmt
			}
		}
		{ //// UserProfiles.ListByUserID4
			if _, exists := ctx.Statements["UserProfiles.ListByUserID4"]; !exists {
				sqlStr := "SELECT p.id as \"p.id\",\r\n                 p.user_id as \"p.user_id\",\r\n                 p.name as \"p.name\",\r\n                 p.value \"p.value\",\r\n                 p.created_at as \"p.created_at\",\r\n                 p.updated_at as \"p.updated_at\",\r\n                 u.id as userids,\r\n                 u.username as usernames\r\n          FROM user_profiles as p LEFT JOIN auth_users as u On p.user_id = u.id\r\n          WHERE p.user_id = #{userID}"
				stmt, err := gobatis.NewMapppedStatement(ctx, "UserProfiles.ListByUserID4",
					gobatis.StatementTypeSelect,
					gobatis.ResultStruct,
					sqlStr)
				if err != nil {
					return err
				}
				ctx.Statements["UserProfiles.ListByUserID4"] = stmt
			}
		}
		return nil
	})
}

func NewUserProfiles(ref gobatis.SqlSession) UserProfiles {
	if ref == nil {
		panic(errors.New("param 'ref' is nil"))
	}
	if reference, ok := ref.(*gobatis.Reference); ok {
		if reference.SqlSession == nil {
			panic(errors.New("param 'ref.SqlSession' is nil"))
		}
	} else if valueReference, ok := ref.(gobatis.Reference); ok {
		if valueReference.SqlSession == nil {
			panic(errors.New("param 'ref.SqlSession' is nil"))
		}
	}
	return &UserProfilesImpl{session: ref}
}

type UserProfilesImpl struct {
	session gobatis.SqlSession
}

func (impl *UserProfilesImpl) Insert(u *UserProfile) (int64, error) {
	return impl.session.Insert(context.Background(), "UserProfiles.Insert",
		[]string{
			"u",
		},
		[]interface{}{
			u,
		})
}

func (impl *UserProfilesImpl) Update(id int64, u *UserProfile) (int64, error) {
	return impl.session.Update(context.Background(), "UserProfiles.Update",
		[]string{
			"id",
			"u",
		},
		[]interface{}{
			id,
			u,
		})
}

func (impl *UserProfilesImpl) SetValue(id int64, value string) (int64, error) {
	return impl.session.Update(context.Background(), "UserProfiles.SetValue",
		[]string{
			"id",
			"value",
		},
		[]interface{}{
			id,
			value,
		})
}

func (impl *UserProfilesImpl) SetUpdatedAt(id int64, updatedAt time.Time) (int64, error) {
	return impl.session.Update(context.Background(), "UserProfiles.SetUpdatedAt",
		[]string{
			"id",
			"updatedAt",
		},
		[]interface{}{
			id,
			updatedAt,
		})
}

func (impl *UserProfilesImpl) DeleteByUserID(userID int64) (int64, error) {
	return impl.session.Delete(context.Background(), "UserProfiles.DeleteByUserID",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		})
}

func (impl *UserProfilesImpl) DeleteByUserIDs(userIDs ...int64) (int64, error) {
	return impl.session.Delete(context.Background(), "UserProfiles.DeleteByUserIDs",
		[]string{
			"userIDs",
		},
		[]interface{}{
			userIDs,
		})
}

func (impl *UserProfilesImpl) DeleteAll() (int64, error) {
	return impl.session.Delete(context.Background(), "UserProfiles.DeleteAll", nil, nil)
}

func (impl *UserProfilesImpl) Delete(id int64) (int64, error) {
	return impl.session.Delete(context.Background(), "UserProfiles.Delete",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		})
}

func (impl *UserProfilesImpl) Get(id int64) (*UserProfile, error) {
	var instance = &UserProfile{}

	err := impl.session.SelectOne(context.Background(), "UserProfiles.Get",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).Scan(instance)
	if err != nil {
		return nil, err
	}

	return instance, nil
}

func (impl *UserProfilesImpl) List(userID int64) ([]*UserProfile, error) {
	var instances []*UserProfile
	results := impl.session.Select(context.Background(), "UserProfiles.List",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		})
	err := results.ScanSlice(&instances)
	if err != nil {
		return nil, err
	}
	return instances, nil
}

func (impl *UserProfilesImpl) Count() (int64, error) {
	var instance int64
	var nullable gobatis.Nullable
	nullable.Value = &instance

	err := impl.session.SelectOne(context.Background(), "UserProfiles.Count", nil, nil).Scan(&nullable)
	if err != nil {
		return 0, err
	}
	if !nullable.Valid {
		return 0, sql.ErrNoRows
	}

	return instance, nil
}

func (impl *UserProfilesImpl) FindByID1(id int64) (p *UserProfile, u *User, err error) {
	var instance = gobatis.NewMultiple()
	instance.SetDelimiter(".")
	p = &UserProfile{}
	instance.Set("p", p, func(ok bool) {
		if !ok {
			p = nil
		}
	})
	u = &User{}
	instance.Set("u", u, func(ok bool) {
		if !ok {
			u = nil
		}
	})

	err = impl.session.SelectOne(context.Background(), "UserProfiles.FindByID1",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).ScanMultiple(instance)
	if err != nil {
		return nil, nil, err
	}
	return p, u, nil
}

func (impl *UserProfilesImpl) FindByID2(id int64) (p UserProfile, u User, err error) {
	var instance = gobatis.NewMultiple()
	instance.Set("p", &p)
	instance.Set("u", &u)

	err = impl.session.SelectOne(context.Background(), "UserProfiles.FindByID2",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).ScanMultiple(instance)
	if err != nil {
		return p, u, err
	}
	return p, u, nil
}

func (impl *UserProfilesImpl) FindByID3(id int64) (p UserProfile, userid int64, username string, err error) {
	var instance = gobatis.NewMultiple()
	instance.SetDefaultReturnName("p")
	instance.Set("p", &p)
	instance.Set("userid", &userid)
	instance.Set("username", &username)

	err = impl.session.SelectOne(context.Background(), "UserProfiles.FindByID3",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).ScanMultiple(instance)
	if err != nil {
		return p, userid, username, err
	}
	return p, userid, username, nil
}

func (impl *UserProfilesImpl) FindByID4(id int64) (p *UserProfile, userid *int64, username *string, err error) {
	var instance = gobatis.NewMultiple()
	p = &UserProfile{}
	instance.Set("p", p, func(ok bool) {
		if !ok {
			p = nil
		}
	})
	userid = new(int64)
	instance.Set("userid", userid, func(ok bool) {
		if !ok {
			userid = nil
		}
	})
	username = new(string)
	instance.Set("username", username, func(ok bool) {
		if !ok {
			username = nil
		}
	})

	err = impl.session.SelectOne(context.Background(), "UserProfiles.FindByID4",
		[]string{
			"id",
		},
		[]interface{}{
			id,
		}).ScanMultiple(instance)
	if err != nil {
		return nil, nil, nil, err
	}
	return p, userid, username, nil
}

func (impl *UserProfilesImpl) ListByUserID1(userID int64) (p []*UserProfile, u []*User, err error) {
	var instance = gobatis.NewMultipleArray()
	instance.Set("p", func(idx int) (interface{}, func(bool)) {
		newInstance := &UserProfile{}
		return newInstance, func(ok bool) {
			if ok {
				p = append(p, newInstance)
			} else {
				p = append(p, nil)
			}
		}
	})
	instance.Set("u", func(idx int) (interface{}, func(bool)) {
		newInstance := &User{}
		return newInstance, func(ok bool) {
			if ok {
				u = append(u, newInstance)
			} else {
				u = append(u, nil)
			}
		}
	})

	err = impl.session.Select(context.Background(), "UserProfiles.ListByUserID1",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		}).ScanMultipleArray(instance)
	if err != nil {
		return nil, nil, err
	}
	return p, u, nil
}

func (impl *UserProfilesImpl) ListByUserID2(userID int64) (p []UserProfile, u []User, err error) {
	var instance = gobatis.NewMultipleArray()
	instance.SetDelimiter(".")
	instance.Set("p", func(idx int) (interface{}, func(bool)) {
		p = append(p, UserProfile{})
		return &p[len(p)-1], nil
	})
	instance.Set("u", func(idx int) (interface{}, func(bool)) {
		u = append(u, User{})
		return &u[len(u)-1], nil
	})

	err = impl.session.Select(context.Background(), "UserProfiles.ListByUserID2",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		}).ScanMultipleArray(instance)
	if err != nil {
		return nil, nil, err
	}
	return p, u, nil
}

func (impl *UserProfilesImpl) ListByUserID3(userID int64) (p []UserProfile, userids []int64, usernames []string, err error) {
	var instance = gobatis.NewMultipleArray()
	instance.SetDefaultReturnName("p")
	instance.Set("p", func(idx int) (interface{}, func(bool)) {
		p = append(p, UserProfile{})
		return &p[len(p)-1], nil
	})
	instance.Set("userids", func(idx int) (interface{}, func(bool)) {
		userids = append(userids, 0)
		return &userids[len(userids)-1], nil
	})
	instance.Set("usernames", func(idx int) (interface{}, func(bool)) {
		usernames = append(usernames, "")
		return &usernames[len(usernames)-1], nil
	})

	err = impl.session.Select(context.Background(), "UserProfiles.ListByUserID3",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		}).ScanMultipleArray(instance)
	if err != nil {
		return nil, nil, nil, err
	}
	return p, userids, usernames, nil
}

func (impl *UserProfilesImpl) ListByUserID4(userID int64) (p []*UserProfile, userids []*int64, usernames []*string, err error) {
	var instance = gobatis.NewMultipleArray()
	instance.SetDelimiter(".")
	instance.Set("p", func(idx int) (interface{}, func(bool)) {
		newInstance := &UserProfile{}
		return newInstance, func(ok bool) {
			if ok {
				p = append(p, newInstance)
			} else {
				p = append(p, nil)
			}
		}
	})
	instance.Set("userids", func(idx int) (interface{}, func(bool)) {
		newInstance := new(int64)
		return newInstance, func(ok bool) {
			if ok {
				userids = append(userids, newInstance)
			} else {
				userids = append(userids, nil)
			}
		}
	})
	instance.Set("usernames", func(idx int) (interface{}, func(bool)) {
		newInstance := new(string)
		return newInstance, func(ok bool) {
			if ok {
				usernames = append(usernames, newInstance)
			} else {
				usernames = append(usernames, nil)
			}
		}
	})

	err = impl.session.Select(context.Background(), "UserProfiles.ListByUserID4",
		[]string{
			"userID",
		},
		[]interface{}{
			userID,
		}).ScanMultipleArray(instance)
	if err != nil {
		return nil, nil, nil, err
	}
	return p, userids, usernames, nil
}
